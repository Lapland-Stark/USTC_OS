# 实验四：

# FAT文件系统的实现

## 实验目标

* 熟悉FAT16的存储结构，利用FUSE实现一个只读的FAT文件系统

## 实验环境

* OS：Ubuntu 14.04 （32位）
## 实验内容
### 一、熟悉使用FUSE

#### 1、FUSE概述

* FUSE（Filesystem in Userspace，用户态文件系统）是一个实现在用户空间的文件系统框架，通过FUSE内核模块的支持，使用者只需要根据fuse提供的接口实现具体的文件操作就可以实现一个文件系统。 
* FUSE主要由三部分组成：FUSE内核模块、用户空间库libfuse以及挂载工具fusermount：

  1. fuse内核模块：实现了和VFS的对接，实现了一个能被用户空间进程打开的设备。
  2. fuse库libfuse：负责和内核空间通信，接收来自/dev/fuse的请求，并将其转化为一系列的函数调用，将结果写回到/dev/fuse；提供的函数可以对fuse文件系统进行挂载卸载、从linux内核读取请求以及发送响应到内核。
  3. 挂载工具：实现对用户态文件系统的挂载。
* 更多详细内容可参考[这个博客](https://blog.csdn.net/ty_laurel/article/details/51685193)。

#### 2、配置FUSE环境

- linux kernel在2.6.14后添加了FUSE模块，因此对于目前的大多数发行版来说只需要安装libfuse库即可。

- 在<https://github.com/libfuse/libfuse>里下载libfuse 2.9.5，然后编译安装： 

  ```shell
  wget -O libfuze-2.9.5.zip https://codeload.github.com/libfuse/libfuse/zip/fuse_2_9_5
  unzip libfuze-2.9.5.zip
  cd libfuse-fuse_2_9_5/
  ./makeconf.sh
  ./configure --prefix=/usr
  make -j4
  sudo make install
  ```

- **编译出错处理：**在执行./makeconf.sh可能会遇到“ libtoolize: not found ”或 “autoreconf: not found”，需要安装libtool和autoconf软件包，ubuntu下可以通过下面的命令安装：

  ```shell
  sudo apt install libtool
  sudo apt install autoconf
  ```

- **注意：**教学实验室的电脑已配置好环境，可以跳过这一步。

#### 3、测试FUSE

- 通过libfuse-fuse_2_9_5/example下的fusexmp进行测试：

  ```
  cd example
  mkdir fuse_test_dir
  ./fusexmp -d fuse_test_dir
  ```

- 这时候在文件管理器中打开fuse_test_dir目录，可以看到当前Linux系统的“/”被挂载到这个目录下。

- 结束测试可以直接在当前终端中Ctrl + C结束程序，或者在新的终端中输入：

  ```shell
  fusermount -u fuse_test_dir
  ```

- **提示：**当执行用户自己实现的fuse程序时，如果出现如下错误，可通过执行上面这条命令卸载对应的文件夹来解决。

  ![fuse_error](./picture/fuse_error.png)




### 二、FAT文件系统

#### 1、FAT格式磁盘镜像的制作过程

- 分为三步：创建文件，格式化文件，挂载使用

  ```shell
  dd if=/dev/zero of=fat-disk.img bs=1M count=100
  
  mkfs.vfat -F 16 fat-disk.img
  
  mkdir mdir
  mount fat-disk.img mdir
  ```


#### 2、FAT16的存储结构

* FAT16文件系统的基本结构依次为：DBR扇区、FAT表1、FAT表2、根目录和数据区，FAT16格式的磁盘的组织方式如下图所示：

  ![fat_format](./picture/fat_format.png)

* **DBR扇区：**DBR是操作系统可以直接访问的第一个扇区,包括一个引导程序和一个称为BPB的本分区参数记录表。BPB参数块记录着本分区的启始扇区、结束扇区、文件存储格式、硬盘介质描述符、根目录大小、*FAT*个数、分配单元的大小等重要参数。下图是一个FAT16文件系统的DBR扇区：

  ![DBR_exp1](./picture/DBR_exp1.png)

  DBR扇区每个字段代表的含义如下：

  ![PBP](./picture/PBP.png)

  根据上面的DBR扇区，我们可以算出各FAT的偏移地址，根目录的偏移地址，数据区的偏移地址。

  FAT1偏移地址：保留扇区（FAT1之前的扇区，包括DBR扇区）之后就是FAT1。因此可以得到，FAT1的偏移地址就是1个扇区的位置，也就是512。

  FAT2偏移地址：FA1偏移地址+FAT1的大小，512+21*512 = 11264。

  根目录偏移地址： FAT2偏移地址+FAT2的大小，11264+21*512= 22016。

  数据区的偏移地址：根目录偏移地址+根目录大小，22016+32*512=38400。其中根目录大小是由根目录项数决定的，每项占32字节。

- **FAT表：**FAT是簇的链表，FAT2与FAT1的内容通常是即时同步的，可以认为两个FAT表完全相同。在根据目录项获取文件的首簇号后，在FAT中找到对应的簇，可以找到下一个簇，一直到文件结束。每个簇用2字节表示簇的状态，具体意义如下表所示：

![FAT_exp2](./picture/FAT_exp2.png)

- **根目录：**FAT文件系统的一个重要思想是把目录当作一个特殊文件来处理，在FAT16中，虽然根目录地位并不等同于普通的目录，但其组织形式和普通的目录并没有不同。不管目录文件所占空间为多少簇，系统都会以32个字节为单位进行目录文件所占簇的分配。每个32字节目录项表示的具体含义如下：

  <img src="./picture/root_exp2.png" alt="root_exp2" style="zoom: 67%;" />

  系统将文件名分成两部分进行存储，即主文件名+扩展名。不记录主文件名与扩展名之间的"."，并且存储成**大写字母**。主文件名不足8个字符以空白符(20H)填充，扩展名不足3个字符同样以空白符(20H)填充。0x0偏移处的取值若为0x0，表明目录项为空；若为0xE5，表明目录项曾被使用，但对应的文件或文件夹已被删除。文件名中的第一个字符若为“.”或“..”表示记录的是一个子目录的目录项，“.”代表当前目录；“..”代表上级目录。

- **FAT表与文件定位：**FAT16文件系统从根目录所占的32个扇区之后的第一个扇区开始以簇为单位进行数据的处理，这之前仍以扇区为单位。对于根目录之后的第一个簇，系统并不编号为0号簇或1号簇，而是编号为2号簇，也就是说数据区顺序上的第1个簇也是编号上的2号簇。

  FAT表以"F8 FF FF FF" 开头，为介质描述单元，并不参与FAT表簇链关系，下图展示了FAT表的内容。为了定位一个文件或目录，需要先找到其对应的目录项，然后根据首簇号查找FAT中的相应表项。

  ![FAT_exp1](./picture/FAT_exp1.png)

  假设一个文件，其首簇号是2，则查看FAT的相对偏移0x4~0x5的内容，此处为0xFFFF，表示存储在2号簇上的文件是个小文件，只占用1个簇便结束了。

  假设另一个文件的首簇号是8，则查看FAT的相对偏移0x10-0x11的内容，为0x0009，就是说该文件继8号簇后的内容会存放在9号簇中；继续查看9号簇的FAT表项内容是0x000A，该文件继9簇后的内容会存放在10号簇中，继续这个过程，会发现文件在11号簇结束。

  

### 三、实验要求

#### 1、实验任务

- 补全代码包中的simple_fat16.c中的TODO标记（一共9处）的部分，实现一个只读的FAT16文件系统。
- **提示：**有需要的话，可采用Linux下的xxd和hexdump等命令或者Windows下的WinHex等十六进制文件编辑工具，分析对应的磁盘镜像文件。

#### 2、运行与测试

- 使用如下的命令编译并测试程序：

  ```shell
  #进入源码目录
  make
  
  #测试一
  ./simple_fat16 --test
  ```

  测试一是为了验证程序的FAT相关部分的代码正确性（以fat16_test.img作为磁盘镜像文件），一共有6个测试目标：

  ![test1](./picture/test1.png)

  通过测试一后，运行如下的命令进行FUSE功能的测试（以fat16.img作为磁盘镜像文件）：

  ```shell
  #测试二
  ./simple_fat16 -d fat_dir
  ```

  这时候在文件管理器中打开fat_dir目录，需要能够看到里面的文件列表，以及正常访问里面的文件：

![test2](./picture/test2.png)

#### 3、评分标准

- 得分由两部分构成：代码运行得分，回答问题得分。
  - 代码运行得分：未能通过测试一，按照完成的测试目标数给分；能正常通过测试二（看到文件+访问文件）得8分，只能看到文件列表但无法正常访问文件得7分。
  - 回答问题得分是指：针对代码实现，助教提问问题，根据回答情况在代码运行分的基础上加分/扣分。

#### 4、提交方式

- 将实验报告、源代码打包为压缩包提交。
  - 本次实验只要求修改simple_fat16.c文件，不能修改其他文件，所以源代码只提交simple_fat16.c文件即可。
- 提交至邮箱：ustc_os2019@163.com
  - 邮件主题、文件名称、压缩包名称 均采用以下格式命名
    - x-学号-姓名（x：代表第x次实验，本次为第4次实验）
      - 例如张三的第4次实验命名为“4-PB17011010-张三”
    - 未按照规范命名的邮件会被忽略、删除
- 实验验收和报告提交截止日期请关注课程主页。













# 拓展实验：

## 实验目标

- 实现一个功能完整的FAT 16文件系统

## 实验内容

#### 1、支持长文件名的FAT 16文件系统

- 在之前的实验中，我们只关注了短文件名（8+3格式）的实现，这种这种方式有很大的局限性：限制了文件名的长度，以及不支持大小写混合的命名方式（短文件名的目录项的文件名需要全大写）。
- **要求：**参考相关资料，实现能够支持长文件名的FAT文件系统，要求能够正常显示fat.img中的文件名。

#### 2、支持写操作的FAT 16文件系统

- 在已有的只读文件基础上，实现可支持创建文件，写文件，删除文件的功能，同时能够支持文件属性的修改。
- **要求：**能够在文件系统中支持touch，cp，rm等命令，支持的功能越多越好。

#### 3、实现线程安全的FAT 16文件系统

- **要求：**在多线程访问文件系统时，需要保证读写请求被正确处理，能够使用fio工具测试文件系统，并且有不错的性能结果。